/**
 * generated by Xtext
 */
package org.spp.cocome.behavior.scoping;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.spp.cocome.behavior.behavior.CollectionType;
import org.spp.cocome.behavior.behavior.ComponentImpl;
import org.spp.cocome.behavior.behavior.DeclarationTypeReference;
import org.spp.cocome.behavior.behavior.InterfaceRealization;
import org.spp.cocome.behavior.behavior.MapType;
import org.spp.cocome.behavior.behavior.TypeReference;
import org.spp.cocome.behavior.behavior.VariableCall;
import org.spp.cocome.behavior.behavior.VariableDecl;
import org.spp.cocome.behavior.mapping.Component;
import org.spp.cocome.behavior.mapping.Interface;
import org.spp.cocome.behavior.mapping.MethodDecl;
import org.spp.cocome.types.types.ComplexType;
import org.spp.cocome.types.types.EntityType;
import org.spp.cocome.types.types.NamedType;
import org.spp.cocome.types.types.Property;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it
 */
@SuppressWarnings("all")
public class BehaviorScopeProvider extends AbstractDeclarativeScopeProvider {
  /**
   * PCM mapping model interface scope.
   */
  public IScope scope_InterfaceRealization_refInterface(final ComponentImpl context, final EReference reference) {
    Component _refComponent = context.getRefComponent();
    EList<Interface> _interfaces = _refComponent.getInterfaces();
    return Scopes.scopeFor(_interfaces);
  }
  
  /**
   * PCM mapping model method scope.
   */
  public IScope scope_MethodImpl_refMethod(final InterfaceRealization context, final EReference reference) {
    Interface _refInterface = context.getRefInterface();
    EList<MethodDecl> _methods = _refInterface.getMethods();
    return Scopes.scopeFor(_methods);
  }
  
  public IScope scope_PropertyCall_property(final VariableCall context, final EReference reference) {
    VariableDecl _variable = context.getVariable();
    final DeclarationTypeReference typeref = _variable.getType();
    NamedType _xifexpression = null;
    if ((typeref instanceof TypeReference)) {
      _xifexpression = ((TypeReference) typeref).getReference();
    } else {
      NamedType _xifexpression_1 = null;
      if ((typeref instanceof CollectionType)) {
        TypeReference _reference = ((CollectionType) typeref).getReference();
        _xifexpression_1 = _reference.getReference();
      } else {
        NamedType _xifexpression_2 = null;
        if ((typeref instanceof MapType)) {
          TypeReference _reference_1 = ((MapType) typeref).getReference();
          _xifexpression_2 = _reference_1.getReference();
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    final NamedType baseTypeRef = _xifexpression;
    if ((baseTypeRef instanceof EntityType)) {
      List<Property> _collectAllProperties = this.collectAllProperties(((EntityType) baseTypeRef));
      return Scopes.scopeFor(_collectAllProperties);
    } else {
      return IScope.NULLSCOPE;
    }
  }
  
  /**
   * Collect all properties of an entity type.
   */
  private List<Property> collectAllProperties(final EntityType type) {
    final List<Property> result = new ArrayList<Property>();
    EList<Property> _properties = type.getProperties();
    result.addAll(_properties);
    ComplexType _parent = type.getParent();
    boolean _notEquals = (!Objects.equal(_parent, null));
    if (_notEquals) {
      ComplexType _parent_1 = type.getParent();
      if ((_parent_1 instanceof EntityType)) {
        ComplexType _parent_2 = type.getParent();
        List<Property> _collectAllProperties = this.collectAllProperties(((EntityType) _parent_2));
        result.addAll(_collectAllProperties);
      }
    }
    return result;
  }
}
