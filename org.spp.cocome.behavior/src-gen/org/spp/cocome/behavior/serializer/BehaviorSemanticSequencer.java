/*
 * generated by Xtext
 */
package org.spp.cocome.behavior.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.spp.cocome.behavior.behavior.Assignment;
import org.spp.cocome.behavior.behavior.BehaviorModel;
import org.spp.cocome.behavior.behavior.BehaviorPackage;
import org.spp.cocome.behavior.behavior.BlockStatement;
import org.spp.cocome.behavior.behavior.BooleanLiteral;
import org.spp.cocome.behavior.behavior.CharLiteral;
import org.spp.cocome.behavior.behavior.CollectionType;
import org.spp.cocome.behavior.behavior.ComponentImpl;
import org.spp.cocome.behavior.behavior.ConstantDecl;
import org.spp.cocome.behavior.behavior.DataAccessStatement;
import org.spp.cocome.behavior.behavior.DataQuery;
import org.spp.cocome.behavior.behavior.Expression;
import org.spp.cocome.behavior.behavior.IfStatement;
import org.spp.cocome.behavior.behavior.Import;
import org.spp.cocome.behavior.behavior.InstantiationExpression;
import org.spp.cocome.behavior.behavior.InterfaceRealization;
import org.spp.cocome.behavior.behavior.LifeCycleMethod;
import org.spp.cocome.behavior.behavior.LoopStatement;
import org.spp.cocome.behavior.behavior.MapType;
import org.spp.cocome.behavior.behavior.MethodImpl;
import org.spp.cocome.behavior.behavior.NumberLiteral;
import org.spp.cocome.behavior.behavior.PropertyCall;
import org.spp.cocome.behavior.behavior.QueryExpression;
import org.spp.cocome.behavior.behavior.RepositoryReference;
import org.spp.cocome.behavior.behavior.ReturnStatement;
import org.spp.cocome.behavior.behavior.StringLiteral;
import org.spp.cocome.behavior.behavior.TypeReference;
import org.spp.cocome.behavior.behavior.TypedValueReference;
import org.spp.cocome.behavior.behavior.VariableCall;
import org.spp.cocome.behavior.behavior.VariableDecl;
import org.spp.cocome.behavior.services.BehaviorGrammarAccess;

@SuppressWarnings("all")
public class BehaviorSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BehaviorGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BehaviorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BehaviorPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case BehaviorPackage.BEHAVIOR_MODEL:
				sequence_BehaviorModel(context, (BehaviorModel) semanticObject); 
				return; 
			case BehaviorPackage.BLOCK_STATEMENT:
				sequence_BlockStatement(context, (BlockStatement) semanticObject); 
				return; 
			case BehaviorPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case BehaviorPackage.CHAR_LITERAL:
				sequence_CharLiteral(context, (CharLiteral) semanticObject); 
				return; 
			case BehaviorPackage.COLLECTION_TYPE:
				sequence_CollectionType(context, (CollectionType) semanticObject); 
				return; 
			case BehaviorPackage.COMPONENT_IMPL:
				sequence_ComponentImpl(context, (ComponentImpl) semanticObject); 
				return; 
			case BehaviorPackage.CONSTANT_DECL:
				sequence_ConstantDecl(context, (ConstantDecl) semanticObject); 
				return; 
			case BehaviorPackage.DATA_ACCESS_STATEMENT:
				sequence_DataAccessStatement(context, (DataAccessStatement) semanticObject); 
				return; 
			case BehaviorPackage.DATA_QUERY:
				sequence_DataQuery(context, (DataQuery) semanticObject); 
				return; 
			case BehaviorPackage.EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| action == grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_AndExpression_CastedExpression_Expression_MultiplicativeExpression_OtherExpression_PostfixOperation_RelationalExpression_UnaryOperation(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getExpressionLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_AndExpression_CastedExpression_MultiplicativeExpression_OtherExpression_PostfixOperation_RelationalExpression_UnaryOperation(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getExpressionLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_CastedExpression_MultiplicativeExpression_OtherExpression_PostfixOperation_RelationalExpression_UnaryOperation(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOtherExpressionRule()) {
					sequence_AdditiveExpression_CastedExpression_MultiplicativeExpression_OtherExpression_PostfixOperation_UnaryOperation(context, (Expression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getOtherExpressionAccess().getExpressionExpressionAction_1_0_0_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getExpressionLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_CastedExpression_MultiplicativeExpression_PostfixOperation_UnaryOperation(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getExpressionLeftAction_1_0_0_0()) {
					sequence_CastedExpression_MultiplicativeExpression_PostfixOperation_UnaryOperation(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCastedExpressionRule()
						|| action == grammarAccess.getCastedExpressionAccess().getExpressionTargetAction_1_0_0_0()) {
					sequence_CastedExpression_PostfixOperation(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnaryOperationRule()) {
					sequence_CastedExpression_PostfixOperation_UnaryOperation(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixOperationRule()) {
					sequence_PostfixOperation(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case BehaviorPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case BehaviorPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case BehaviorPackage.INSTANTIATION_EXPRESSION:
				sequence_InstantiationExpression(context, (InstantiationExpression) semanticObject); 
				return; 
			case BehaviorPackage.INTERFACE_REALIZATION:
				sequence_InterfaceRealization(context, (InterfaceRealization) semanticObject); 
				return; 
			case BehaviorPackage.LIFE_CYCLE_METHOD:
				sequence_LifeCycleMethod(context, (LifeCycleMethod) semanticObject); 
				return; 
			case BehaviorPackage.LOOP_STATEMENT:
				sequence_LoopStatement(context, (LoopStatement) semanticObject); 
				return; 
			case BehaviorPackage.MAP_TYPE:
				sequence_MapType(context, (MapType) semanticObject); 
				return; 
			case BehaviorPackage.METHOD_IMPL:
				sequence_MethodImpl(context, (MethodImpl) semanticObject); 
				return; 
			case BehaviorPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case BehaviorPackage.PROPERTY_CALL:
				sequence_PropertyCall(context, (PropertyCall) semanticObject); 
				return; 
			case BehaviorPackage.QUERY_EXPRESSION:
				sequence_QueryExpression(context, (QueryExpression) semanticObject); 
				return; 
			case BehaviorPackage.REPOSITORY_REFERENCE:
				sequence_RepositoryReference(context, (RepositoryReference) semanticObject); 
				return; 
			case BehaviorPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case BehaviorPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case BehaviorPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case BehaviorPackage.TYPED_VALUE_REFERENCE:
				sequence_TypedValueReference(context, (TypedValueReference) semanticObject); 
				return; 
			case BehaviorPackage.VARIABLE_CALL:
				sequence_VariableCall(context, (VariableCall) semanticObject); 
				return; 
			case BehaviorPackage.VARIABLE_DECL:
				sequence_VariableDecl(context, (VariableDecl) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     Expression.Expression_1_0_0_0 returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (left=Expression_Expression_1_0_0_0 feature='||' right=AndExpression) | 
	 *         (left=AndExpression_Expression_1_0_0_0 feature='&&' right=RelationalExpression) | 
	 *         (
	 *             left=RelationalExpression_Expression_1_0_0_0 
	 *             (
	 *                 feature='==' | 
	 *                 feature='!=' | 
	 *                 feature='>' | 
	 *                 feature='<' | 
	 *                 feature='>=' | 
	 *                 feature='<='
	 *             ) 
	 *             right=OtherExpression
	 *         ) | 
	 *         (expression=OtherExpression_Expression_1_0_0_0 feature='instanceof' type=TypeReference) | 
	 *         (left=AdditiveExpression_Expression_1_0_0_0 (feature='+' | feature='-') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_Expression_1_0_0_0 (feature='*' | feature='/' | feature='%' | feature='**') right=UnaryOperation) | 
	 *         (feature='!' operand=UnaryOperation) | 
	 *         (target=CastedExpression_Expression_1_0_0_0 feature='as' type=TypeReference) | 
	 *         (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_CastedExpression_Expression_MultiplicativeExpression_OtherExpression_PostfixOperation_RelationalExpression_UnaryOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns Expression
	 *     AndExpression.Expression_1_0_0_0 returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (left=AndExpression_Expression_1_0_0_0 feature='&&' right=RelationalExpression) | 
	 *         (
	 *             left=RelationalExpression_Expression_1_0_0_0 
	 *             (
	 *                 feature='==' | 
	 *                 feature='!=' | 
	 *                 feature='>' | 
	 *                 feature='<' | 
	 *                 feature='>=' | 
	 *                 feature='<='
	 *             ) 
	 *             right=OtherExpression
	 *         ) | 
	 *         (expression=OtherExpression_Expression_1_0_0_0 feature='instanceof' type=TypeReference) | 
	 *         (left=AdditiveExpression_Expression_1_0_0_0 (feature='+' | feature='-') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_Expression_1_0_0_0 (feature='*' | feature='/' | feature='%' | feature='**') right=UnaryOperation) | 
	 *         (feature='!' operand=UnaryOperation) | 
	 *         (target=CastedExpression_Expression_1_0_0_0 feature='as' type=TypeReference) | 
	 *         (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_CastedExpression_MultiplicativeExpression_OtherExpression_PostfixOperation_RelationalExpression_UnaryOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression returns Expression
	 *     RelationalExpression.Expression_1_0_0_0 returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             left=RelationalExpression_Expression_1_0_0_0 
	 *             (
	 *                 feature='==' | 
	 *                 feature='!=' | 
	 *                 feature='>' | 
	 *                 feature='<' | 
	 *                 feature='>=' | 
	 *                 feature='<='
	 *             ) 
	 *             right=OtherExpression
	 *         ) | 
	 *         (expression=OtherExpression_Expression_1_0_0_0 feature='instanceof' type=TypeReference) | 
	 *         (left=AdditiveExpression_Expression_1_0_0_0 (feature='+' | feature='-') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_Expression_1_0_0_0 (feature='*' | feature='/' | feature='%' | feature='**') right=UnaryOperation) | 
	 *         (feature='!' operand=UnaryOperation) | 
	 *         (target=CastedExpression_Expression_1_0_0_0 feature='as' type=TypeReference) | 
	 *         (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 *     )
	 */
	protected void sequence_AdditiveExpression_CastedExpression_MultiplicativeExpression_OtherExpression_PostfixOperation_RelationalExpression_UnaryOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OtherExpression returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (expression=OtherExpression_Expression_1_0_0_0 feature='instanceof' type=TypeReference) | 
	 *         (left=AdditiveExpression_Expression_1_0_0_0 (feature='+' | feature='-') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_Expression_1_0_0_0 (feature='*' | feature='/' | feature='%' | feature='**') right=UnaryOperation) | 
	 *         (feature='!' operand=UnaryOperation) | 
	 *         (target=CastedExpression_Expression_1_0_0_0 feature='as' type=TypeReference) | 
	 *         (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 *     )
	 */
	protected void sequence_AdditiveExpression_CastedExpression_MultiplicativeExpression_OtherExpression_PostfixOperation_UnaryOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OtherExpression.Expression_1_0_0_0 returns Expression
	 *     AdditiveExpression returns Expression
	 *     AdditiveExpression.Expression_1_0_0_0 returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (left=AdditiveExpression_Expression_1_0_0_0 (feature='+' | feature='-') right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_Expression_1_0_0_0 (feature='*' | feature='/' | feature='%' | feature='**') right=UnaryOperation) | 
	 *         (feature='!' operand=UnaryOperation) | 
	 *         (target=CastedExpression_Expression_1_0_0_0 feature='as' type=TypeReference) | 
	 *         (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 *     )
	 */
	protected void sequence_AdditiveExpression_CastedExpression_MultiplicativeExpression_PostfixOperation_UnaryOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (variable=VariableCall expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getVariableVariableCallParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BehaviorModel returns BehaviorModel
	 *
	 * Constraint:
	 *     (name=QualifiedName (imports+=Import | repositories+=RepositoryReference)* componentImpl=ComponentImpl)
	 */
	protected void sequence_BehaviorModel(ISerializationContext context, BehaviorModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns BlockStatement
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_BlockStatement(ISerializationContext context, BlockStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     Expression.Expression_1_0_0_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.Expression_1_0_0_0 returns BooleanLiteral
	 *     RelationalExpression returns BooleanLiteral
	 *     RelationalExpression.Expression_1_0_0_0 returns BooleanLiteral
	 *     OtherExpression returns BooleanLiteral
	 *     OtherExpression.Expression_1_0_0_0 returns BooleanLiteral
	 *     AdditiveExpression returns BooleanLiteral
	 *     AdditiveExpression.Expression_1_0_0_0 returns BooleanLiteral
	 *     MultiplicativeExpression returns BooleanLiteral
	 *     MultiplicativeExpression.Expression_1_0_0_0 returns BooleanLiteral
	 *     UnaryOperation returns BooleanLiteral
	 *     CastedExpression returns BooleanLiteral
	 *     CastedExpression.Expression_1_0_0_0 returns BooleanLiteral
	 *     PostfixOperation returns BooleanLiteral
	 *     PostfixOperation.Expression_1_0_0 returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralAccess().getValueBOOLEANParserRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpression returns Expression
	 *     MultiplicativeExpression.Expression_1_0_0_0 returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (left=MultiplicativeExpression_Expression_1_0_0_0 (feature='*' | feature='/' | feature='%' | feature='**') right=UnaryOperation) | 
	 *         (feature='!' operand=UnaryOperation) | 
	 *         (target=CastedExpression_Expression_1_0_0_0 feature='as' type=TypeReference) | 
	 *         (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 *     )
	 */
	protected void sequence_CastedExpression_MultiplicativeExpression_PostfixOperation_UnaryOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CastedExpression returns Expression
	 *     CastedExpression.Expression_1_0_0_0 returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (target=CastedExpression_Expression_1_0_0_0 feature='as' type=TypeReference) | 
	 *         (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 *     )
	 */
	protected void sequence_CastedExpression_PostfixOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryOperation returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (feature='!' operand=UnaryOperation) | 
	 *         (target=CastedExpression_Expression_1_0_0_0 feature='as' type=TypeReference) | 
	 *         (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 *     )
	 */
	protected void sequence_CastedExpression_PostfixOperation_UnaryOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CharLiteral
	 *     Expression.Expression_1_0_0_0 returns CharLiteral
	 *     AndExpression returns CharLiteral
	 *     AndExpression.Expression_1_0_0_0 returns CharLiteral
	 *     RelationalExpression returns CharLiteral
	 *     RelationalExpression.Expression_1_0_0_0 returns CharLiteral
	 *     OtherExpression returns CharLiteral
	 *     OtherExpression.Expression_1_0_0_0 returns CharLiteral
	 *     AdditiveExpression returns CharLiteral
	 *     AdditiveExpression.Expression_1_0_0_0 returns CharLiteral
	 *     MultiplicativeExpression returns CharLiteral
	 *     MultiplicativeExpression.Expression_1_0_0_0 returns CharLiteral
	 *     UnaryOperation returns CharLiteral
	 *     CastedExpression returns CharLiteral
	 *     CastedExpression.Expression_1_0_0_0 returns CharLiteral
	 *     PostfixOperation returns CharLiteral
	 *     PostfixOperation.Expression_1_0_0 returns CharLiteral
	 *     PrimaryExpression returns CharLiteral
	 *     Literal returns CharLiteral
	 *     CharLiteral returns CharLiteral
	 *
	 * Constraint:
	 *     value=CHARACTER
	 */
	protected void sequence_CharLiteral(ISerializationContext context, CharLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.CHAR_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.CHAR_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharLiteralAccess().getValueCHARACTERTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclarationTypeReference returns CollectionType
	 *     CollectionType returns CollectionType
	 *
	 * Constraint:
	 *     (reference=TypeReference size=INT?)
	 */
	protected void sequence_CollectionType(ISerializationContext context, CollectionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComponentImpl returns ComponentImpl
	 *
	 * Constraint:
	 *     (
	 *         kind=ComponentKind? 
	 *         refComponent=[Component|QualifiedName] 
	 *         (localDeclarations+=VariableDecl | localDeclarations+=ConstantDecl)* 
	 *         postConstruct=LifeCycleMethod? 
	 *         preDestroy=LifeCycleMethod? 
	 *         interfaces+=InterfaceRealization*
	 *     )
	 */
	protected void sequence_ComponentImpl(ISerializationContext context, ComponentImpl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstantDecl returns ConstantDecl
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_ConstantDecl(ISerializationContext context, ConstantDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.CONSTANT_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.CONSTANT_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.CONSTANT_DECL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.CONSTANT_DECL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantDeclAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantDeclAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DataAccessStatement
	 *     DataAccessStatement returns DataAccessStatement
	 *
	 * Constraint:
	 *     (operation=DataAccessOperation variable=[VariableDecl|ID])
	 */
	protected void sequence_DataAccessStatement(ISerializationContext context, DataAccessStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.DATA_ACCESS_STATEMENT__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.DATA_ACCESS_STATEMENT__OPERATION));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.DATA_ACCESS_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.DATA_ACCESS_STATEMENT__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataAccessStatementAccess().getOperationDataAccessOperationEnumRuleCall_0_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getDataAccessStatementAccess().getVariableVariableDeclIDTerminalRuleCall_1_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DataQuery
	 *     Expression.Expression_1_0_0_0 returns DataQuery
	 *     AndExpression returns DataQuery
	 *     AndExpression.Expression_1_0_0_0 returns DataQuery
	 *     RelationalExpression returns DataQuery
	 *     RelationalExpression.Expression_1_0_0_0 returns DataQuery
	 *     OtherExpression returns DataQuery
	 *     OtherExpression.Expression_1_0_0_0 returns DataQuery
	 *     AdditiveExpression returns DataQuery
	 *     AdditiveExpression.Expression_1_0_0_0 returns DataQuery
	 *     MultiplicativeExpression returns DataQuery
	 *     MultiplicativeExpression.Expression_1_0_0_0 returns DataQuery
	 *     UnaryOperation returns DataQuery
	 *     CastedExpression returns DataQuery
	 *     CastedExpression.Expression_1_0_0_0 returns DataQuery
	 *     PostfixOperation returns DataQuery
	 *     PostfixOperation.Expression_1_0_0 returns DataQuery
	 *     PrimaryExpression returns DataQuery
	 *     DataQuery returns DataQuery
	 *
	 * Constraint:
	 *     (type=DeclarationTypeReference query=QueryExpression)
	 */
	protected void sequence_DataQuery(ISerializationContext context, DataQuery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.EXPRESSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.DATA_QUERY__QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.DATA_QUERY__QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataQueryAccess().getTypeDeclarationTypeReferenceParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDataQueryAccess().getQueryQueryExpressionParserRuleCall_2_0(), semanticObject.getQuery());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (expr=Expression ifStatement=BlockStatement elseStatement=BlockStatement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns InstantiationExpression
	 *     Expression.Expression_1_0_0_0 returns InstantiationExpression
	 *     AndExpression returns InstantiationExpression
	 *     AndExpression.Expression_1_0_0_0 returns InstantiationExpression
	 *     RelationalExpression returns InstantiationExpression
	 *     RelationalExpression.Expression_1_0_0_0 returns InstantiationExpression
	 *     OtherExpression returns InstantiationExpression
	 *     OtherExpression.Expression_1_0_0_0 returns InstantiationExpression
	 *     AdditiveExpression returns InstantiationExpression
	 *     AdditiveExpression.Expression_1_0_0_0 returns InstantiationExpression
	 *     MultiplicativeExpression returns InstantiationExpression
	 *     MultiplicativeExpression.Expression_1_0_0_0 returns InstantiationExpression
	 *     UnaryOperation returns InstantiationExpression
	 *     CastedExpression returns InstantiationExpression
	 *     CastedExpression.Expression_1_0_0_0 returns InstantiationExpression
	 *     PostfixOperation returns InstantiationExpression
	 *     PostfixOperation.Expression_1_0_0 returns InstantiationExpression
	 *     PrimaryExpression returns InstantiationExpression
	 *     InstantiationExpression returns InstantiationExpression
	 *
	 * Constraint:
	 *     (type=TypeReference parameters+=Expression)
	 */
	protected void sequence_InstantiationExpression(ISerializationContext context, InstantiationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceRealization returns InterfaceRealization
	 *
	 * Constraint:
	 *     (refInterface=[Interface|QualifiedName] methods+=MethodImpl*)
	 */
	protected void sequence_InterfaceRealization(ISerializationContext context, InterfaceRealization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LifeCycleMethod returns LifeCycleMethod
	 *
	 * Constraint:
	 *     body=BlockStatement
	 */
	protected void sequence_LifeCycleMethod(ISerializationContext context, LifeCycleMethod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LIFE_CYCLE_METHOD__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LIFE_CYCLE_METHOD__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLifeCycleMethodAccess().getBodyBlockStatementParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LoopStatement
	 *     LoopStatement returns LoopStatement
	 *
	 * Constraint:
	 *     (variable=VariableDecl expression=Expression statement=BlockStatement)
	 */
	protected void sequence_LoopStatement(ISerializationContext context, LoopStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOOP_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOOP_STATEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOOP_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOOP_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.LOOP_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.LOOP_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopStatementAccess().getVariableVariableDeclParserRuleCall_2_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getLoopStatementAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getLoopStatementAccess().getStatementBlockStatementParserRuleCall_6_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclarationTypeReference returns MapType
	 *     MapType returns MapType
	 *
	 * Constraint:
	 *     (reference=TypeReference keyType=TypeReference)
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.MAP_TYPE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.MAP_TYPE__REFERENCE));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.MAP_TYPE__KEY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.MAP_TYPE__KEY_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getReferenceTypeReferenceParserRuleCall_0_0(), semanticObject.getReference());
		feeder.accept(grammarAccess.getMapTypeAccess().getKeyTypeTypeReferenceParserRuleCall_2_0_0(), semanticObject.getKeyType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MethodImpl returns MethodImpl
	 *
	 * Constraint:
	 *     (refMethod=[MethodDecl|QualifiedName] body=BlockStatement)
	 */
	protected void sequence_MethodImpl(ISerializationContext context, MethodImpl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.METHOD_IMPL__REF_METHOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.METHOD_IMPL__REF_METHOD));
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.METHOD_IMPL__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.METHOD_IMPL__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMethodImplAccess().getRefMethodMethodDeclQualifiedNameParserRuleCall_1_0_1(), semanticObject.getRefMethod());
		feeder.accept(grammarAccess.getMethodImplAccess().getBodyBlockStatementParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     Expression.Expression_1_0_0_0 returns NumberLiteral
	 *     AndExpression returns NumberLiteral
	 *     AndExpression.Expression_1_0_0_0 returns NumberLiteral
	 *     RelationalExpression returns NumberLiteral
	 *     RelationalExpression.Expression_1_0_0_0 returns NumberLiteral
	 *     OtherExpression returns NumberLiteral
	 *     OtherExpression.Expression_1_0_0_0 returns NumberLiteral
	 *     AdditiveExpression returns NumberLiteral
	 *     AdditiveExpression.Expression_1_0_0_0 returns NumberLiteral
	 *     MultiplicativeExpression returns NumberLiteral
	 *     MultiplicativeExpression.Expression_1_0_0_0 returns NumberLiteral
	 *     UnaryOperation returns NumberLiteral
	 *     CastedExpression returns NumberLiteral
	 *     CastedExpression.Expression_1_0_0_0 returns NumberLiteral
	 *     PostfixOperation returns NumberLiteral
	 *     PostfixOperation.Expression_1_0_0 returns NumberLiteral
	 *     PrimaryExpression returns NumberLiteral
	 *     Literal returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueNUMBERParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PostfixOperation returns Expression
	 *
	 * Constraint:
	 *     (operand=PostfixOperation_Expression_1_0_0 (feature='++' | feature='--'))
	 */
	protected void sequence_PostfixOperation(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyCall returns PropertyCall
	 *
	 * Constraint:
	 *     (property=[Property|ID] index=Expression? subProperty=PropertyCall?)
	 */
	protected void sequence_PropertyCall(ISerializationContext context, PropertyCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QueryExpression returns QueryExpression
	 *
	 * Constraint:
	 *     (left=QueryElement right=QueryExpression?)
	 */
	protected void sequence_QueryExpression(ISerializationContext context, QueryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RepositoryReference returns RepositoryReference
	 *
	 * Constraint:
	 *     reference=STRING
	 */
	protected void sequence_RepositoryReference(ISerializationContext context, RepositoryReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.REPOSITORY_REFERENCE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.REPOSITORY_REFERENCE__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepositoryReferenceAccess().getReferenceSTRINGTerminalRuleCall_1_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.RETURN_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.RETURN_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     Expression.Expression_1_0_0_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.Expression_1_0_0_0 returns StringLiteral
	 *     RelationalExpression returns StringLiteral
	 *     RelationalExpression.Expression_1_0_0_0 returns StringLiteral
	 *     OtherExpression returns StringLiteral
	 *     OtherExpression.Expression_1_0_0_0 returns StringLiteral
	 *     AdditiveExpression returns StringLiteral
	 *     AdditiveExpression.Expression_1_0_0_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.Expression_1_0_0_0 returns StringLiteral
	 *     UnaryOperation returns StringLiteral
	 *     CastedExpression returns StringLiteral
	 *     CastedExpression.Expression_1_0_0_0 returns StringLiteral
	 *     PostfixOperation returns StringLiteral
	 *     PostfixOperation.Expression_1_0_0 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     QueryElement returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclarationTypeReference returns TypeReference
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     reference=[NamedType|ID]
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.TYPE_REFERENCE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.TYPE_REFERENCE__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeReferenceAccess().getReferenceNamedTypeIDTerminalRuleCall_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QueryElement returns TypedValueReference
	 *     TypedValueReference returns TypedValueReference
	 *
	 * Constraint:
	 *     typedValue=[TypedValue|ID]
	 */
	protected void sequence_TypedValueReference(ISerializationContext context, TypedValueReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorPackage.Literals.TYPED_VALUE_REFERENCE__TYPED_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorPackage.Literals.TYPED_VALUE_REFERENCE__TYPED_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedValueReferenceAccess().getTypedValueTypedValueIDTerminalRuleCall_0_1(), semanticObject.getTypedValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableCall returns VariableCall
	 *     Expression returns VariableCall
	 *     Expression.Expression_1_0_0_0 returns VariableCall
	 *     AndExpression returns VariableCall
	 *     AndExpression.Expression_1_0_0_0 returns VariableCall
	 *     RelationalExpression returns VariableCall
	 *     RelationalExpression.Expression_1_0_0_0 returns VariableCall
	 *     OtherExpression returns VariableCall
	 *     OtherExpression.Expression_1_0_0_0 returns VariableCall
	 *     AdditiveExpression returns VariableCall
	 *     AdditiveExpression.Expression_1_0_0_0 returns VariableCall
	 *     MultiplicativeExpression returns VariableCall
	 *     MultiplicativeExpression.Expression_1_0_0_0 returns VariableCall
	 *     UnaryOperation returns VariableCall
	 *     CastedExpression returns VariableCall
	 *     CastedExpression.Expression_1_0_0_0 returns VariableCall
	 *     PostfixOperation returns VariableCall
	 *     PostfixOperation.Expression_1_0_0 returns VariableCall
	 *     PrimaryExpression returns VariableCall
	 *
	 * Constraint:
	 *     (variable=[VariableDecl|ID] index=Expression? subProperty=PropertyCall?)
	 */
	protected void sequence_VariableCall(ISerializationContext context, VariableCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedValue returns VariableDecl
	 *     VariableDecl returns VariableDecl
	 *
	 * Constraint:
	 *     ((modifier='var' | modifier='val') type=DeclarationTypeReference name=ID)
	 */
	protected void sequence_VariableDecl(ISerializationContext context, VariableDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
